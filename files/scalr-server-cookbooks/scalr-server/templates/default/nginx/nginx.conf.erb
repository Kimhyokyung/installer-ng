user <%= node[:scalr_server][:app][:user] %>;
worker_processes auto;

daemon off;

error_log <%= log_dir_for node, 'nginx' %>/web.error.log;

events {
  worker_connections 2048;
}

http {

  sendfile on;
  tcp_nopush on;
  tcp_nodelay on;

  types_hash_max_size 2048;
  client_max_body_size 20M;

  include mime.types;
  default_type application/octet-stream;

  log_format scalr '$remote_addr - $remote_user [$time_local] ' '"$request" $status $body_bytes_sent ' '"$gzip_ratio" "$request_time"';

  keepalive_timeout 60;

  gzip on;
  gzip_disable "MSIE [1-6]\.(?!.*SV1)";
  gzip_comp_level 6;
  gzip_vary on;
  gzip_types text/plain text/xml text/x-js text/javascript text/css application/xml application/xhtml+xml application/x-javascript application/javascript application/json;

  server_tokens off;
  charset utf-8;
  etag off;

  <% if enable_module?(node, :proxy) %>
    upstream app {
      least_conn;

      <% node[:scalr_server][:proxy][:app_upstreams].each do |upstream| %>
        server <%= upstream %>;
      <% end %>
    }

    upstream graphics {
      least_conn;

      <% node[:scalr_server][:proxy][:graphics_upstreams].each do |upstream| %>
        server <%= upstream %>;
      <% end %>
    }

    upstream plotter {
      least_conn;

      <% node[:scalr_server][:proxy][:plotter_upstreams].each do |upstream| %>
        server <%= upstream %>;
      <% end %>
    }

    upstream repos {
      least_conn;

      <% node[:scalr_server][:proxy][:repos_upstreams].each do |upstream| %>
        server <%= upstream %>;
      <% end %>
    }
  	
    server {
      listen <%= node[:scalr_server][:proxy][:bind_host] %>:<%= node[:scalr_server][:proxy][:bind_port] %> default_server backlog=4096;
      server_name _;

      access_log <%= log_dir_for node, 'nginx' %>/web.proxy.access.log scalr;
      error_log <%= log_dir_for node, 'nginx' %>/web.proxy.error.log;

      <% if node[:scalr_server][:proxy][:ssl_enable] and node[:scalr_server][:proxy][:ssl_redirect] %>
        return 301 https://<%= node[:scalr_server][:routing][:endpoint_host] %>$request_uri;
      <% else %>
        include proxy_common.conf;
      <% end %>
    }

    <% if node[:scalr_server][:proxy][:ssl_enable] %>
      server {
        listen <%= node[:scalr_server][:proxy][:bind_host] %>:<%= node[:scalr_server][:proxy][:ssl_bind_port] %> ssl default_server backlog=4096;
        server_name _;

        access_log <%= log_dir_for node, 'nginx' %>/web.proxy.access.log scalr;
        error_log <%= log_dir_for node, 'nginx' %>/web.proxy.error.log;

        ssl_certificate <%= node[:scalr_server][:proxy][:ssl_cert_path] %>;
        ssl_certificate_key <%= node[:scalr_server][:proxy][:ssl_key_path] %>;

        ssl_prefer_server_ciphers on;
        ssl_buffer_size 8k;
        ssl_session_cache shared:SSL:1m;
        ssl_session_timeout 5m;

        include proxy_common.conf;
      }
    <% end %>
  <% end %>

  <% if enable_module?(node, :repos) %>
    server {
      listen <%= node[:scalr_server][:repos][:bind_host] %>:<%= node[:scalr_server][:repos][:bind_port] %> default_server backlog=4096;
      server_name _;
      access_log <%= log_dir_for node, 'nginx' %>/web.repos.access.log;
      error_log <%= log_dir_for node, 'nginx' %>/web.repos.error.log;
      root <%= node[:scalr_server][:repos][:root] %>/current;
      autoindex on;
      disable_symlinks off;
    }
  <% end %>

}

stream {

  server {
    listen <%= node[:scalr_server][:proxy][:amqps_bind_port] %>;
    proxy_pass rabbitmq_hosts;
  }

  upstream rabbitmq_hosts {
    <% node[:scalr_server][:proxy][:rabbitmq_upstreams].each do |upstream| %>
      server <%= upstream %>:<%= node[:scalr_server][:rabbitmq][:bind_port] %>;
    <% end %>
  }

}
